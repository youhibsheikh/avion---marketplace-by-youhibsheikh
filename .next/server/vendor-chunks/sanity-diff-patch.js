"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanity-diff-patch";
exports.ids = ["vendor-chunks/sanity-diff-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanity-diff-patch/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/sanity-diff-patch/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiffError: () => (/* binding */ DiffError),\n/* harmony export */   diffItem: () => (/* binding */ diffItem),\n/* harmony export */   diffPatch: () => (/* binding */ diffPatch)\n/* harmony export */ });\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\nconst IS_DOTTABLE_RE = /^[A-Za-z_][A-Za-z0-9_]*$/;\nfunction pathToString(path) {\n  return path.reduce((target, segment, i) => {\n    if (Array.isArray(segment))\n      return `${target}[${segment.join(\":\")}]`;\n    if (isKeyedObject(segment))\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (typeof segment == \"number\")\n      return `${target}[${segment}]`;\n    if (typeof segment == \"string\" && !IS_DOTTABLE_RE.test(segment))\n      return `${target}['${segment}']`;\n    if (typeof segment == \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    throw new Error(`Unsupported path segment \"${segment}\"`);\n  }, \"\");\n}\nfunction isKeyedObject(obj) {\n  return typeof obj == \"object\" && typeof obj._key == \"string\";\n}\nclass DiffError extends Error {\n  path;\n  value;\n  serializedPath;\n  constructor(message, path, value) {\n    const serializedPath = pathToString(path);\n    super(`${message} (at '${serializedPath}')`), this.path = path, this.serializedPath = serializedPath, this.value = value;\n  }\n}\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i, propPattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/, propStartPattern = /^[a-z_]/i;\nfunction validateProperty(property, value, path) {\n  if (!propStartPattern.test(property))\n    throw new DiffError(\"Keys must start with a letter (a-z)\", path.concat(property), value);\n  if (!propPattern.test(property))\n    throw new DiffError(\n      \"Keys can only contain letters, numbers and underscores\",\n      path.concat(property),\n      value\n    );\n  if (property === \"_key\" || property === \"_ref\" || property === \"_type\") {\n    if (typeof value != \"string\")\n      throw new DiffError(\"Keys must be strings\", path.concat(property), value);\n    if (!idPattern.test(value))\n      throw new DiffError(\"Invalid key - use less exotic characters\", path.concat(property), value);\n  }\n  return property;\n}\nconst ignoredKeys = [\"_id\", \"_type\", \"_createdAt\", \"_updatedAt\", \"_rev\"], defaultOptions = {\n  hideWarnings: !1,\n  diffMatchPatch: {\n    enabled: !0,\n    // Only use diff-match-patch if target string is longer than this threshold\n    lengthThresholdAbsolute: 30,\n    // Only use generated diff-match-patch if the patch length is less than or equal to\n    // (targetString * relative). Example: A 100 character target with a relative factor\n    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n    // it will fall back to a regular `set` patch.\n    lengthThresholdRelative: 1.2\n  }\n};\nfunction mergeOptions(options) {\n  return {\n    ...defaultOptions,\n    ...options,\n    diffMatchPatch: { ...defaultOptions.diffMatchPatch, ...options.diffMatchPatch || {} }\n  };\n}\nfunction diffPatch(itemA, itemB, opts) {\n  const options = mergeOptions(opts || {}), id = options.id || itemA._id === itemB._id && itemA._id, revisionLocked = options.ifRevisionID, ifRevisionID = typeof revisionLocked == \"boolean\" ? itemA._rev : revisionLocked, basePath = options.basePath || [];\n  if (!id)\n    throw new Error(\n      \"_id on itemA and itemB not present or differs, specify document id the mutations should be applied to\"\n    );\n  if (revisionLocked === !0 && !ifRevisionID)\n    throw new Error(\n      \"`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.\"\n    );\n  if (basePath.length === 0 && itemA._type !== itemB._type)\n    throw new Error(`_type is immutable and cannot be changed (${itemA._type} => ${itemB._type})`);\n  const operations = diffItem(itemA, itemB, options, basePath, []);\n  return serializePatches(operations, { id, ifRevisionID: revisionLocked ? ifRevisionID : void 0 });\n}\nfunction diffItem(itemA, itemB, opts = defaultOptions, path = [], patches = []) {\n  if (itemA === itemB)\n    return patches;\n  const aType = Array.isArray(itemA) ? \"array\" : typeof itemA, bType = Array.isArray(itemB) ? \"array\" : typeof itemB, aIsUndefined = aType === \"undefined\", bIsUndefined = bType === \"undefined\";\n  if (aIsUndefined && !bIsUndefined)\n    return patches.push({ op: \"set\", path, value: itemB }), patches;\n  if (!aIsUndefined && bIsUndefined)\n    return patches.push({ op: \"unset\", path }), patches;\n  const options = mergeOptions(opts), dataType = aIsUndefined ? bType : aType;\n  return dataType === \"object\" || dataType === \"array\" ? aType !== bType ? (patches.push({ op: \"set\", path, value: itemB }), patches) : dataType === \"array\" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches) : diffPrimitive(itemA, itemB, options, path, patches);\n}\nfunction diffObject(itemA, itemB, options, path, patches) {\n  const atRoot = path.length === 0, aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map((key) => validateProperty(key, itemA[key], path)), aKeysLength = aKeys.length, bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map((key) => validateProperty(key, itemB[key], path)), bKeysLength = bKeys.length;\n  for (let i = 0; i < aKeysLength; i++) {\n    const key = aKeys[i];\n    key in itemB || patches.push({ op: \"unset\", path: path.concat(key) });\n  }\n  for (let i = 0; i < bKeysLength; i++) {\n    const key = bKeys[i];\n    diffItem(itemA[key], itemB[key], options, path.concat([key]), patches);\n  }\n  return patches;\n}\nfunction diffArray(itemA, itemB, options, path, patches) {\n  if (itemB.length > itemA.length && patches.push({\n    op: \"insert\",\n    after: path.concat([-1]),\n    items: itemB.slice(itemA.length).map((item, i) => nullifyUndefined(item, path, i, options))\n  }), itemB.length < itemA.length) {\n    const isSingle = itemA.length - itemB.length === 1, unsetItems = itemA.slice(itemB.length);\n    isRevisionLocked(options) || !isUniquelyKeyed(unsetItems) ? patches.push({\n      op: \"unset\",\n      path: path.concat([isSingle ? itemB.length : [itemB.length, \"\"]])\n    }) : patches.push(\n      ...unsetItems.map(\n        (item) => ({ op: \"unset\", path: path.concat({ _key: item._key }) })\n      )\n    );\n  }\n  for (let i = 0; i < itemB.length; i++)\n    if (Array.isArray(itemB[i]))\n      throw new DiffError(\"Multi-dimensional arrays not supported\", path.concat(i), itemB[i]);\n  const overlapping = Math.min(itemA.length, itemB.length), segmentA = itemA.slice(0, overlapping), segmentB = itemB.slice(0, overlapping);\n  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);\n}\nfunction diffArrayByIndex(itemA, itemB, options, path, patches) {\n  for (let i = 0; i < itemA.length; i++)\n    diffItem(\n      itemA[i],\n      nullifyUndefined(itemB[i], path, i, options),\n      options,\n      path.concat(i),\n      patches\n    );\n  return patches;\n}\nfunction diffArrayByKey(itemA, itemB, options, path, patches) {\n  const keyedA = indexByKey(itemA), keyedB = indexByKey(itemB);\n  if (!arrayIsEqual(keyedA.keys, keyedB.keys))\n    return diffArrayByIndex(itemA, itemB, options, path, patches);\n  for (let i = 0; i < keyedB.keys.length; i++) {\n    const key = keyedB.keys[i], valueA = keyedA.index[key], valueB = nullifyUndefined(keyedB.index[key], path, i, options);\n    diffItem(valueA, valueB, options, path.concat({ _key: key }), patches);\n  }\n  return patches;\n}\nfunction getDiffMatchPatch(itemA, itemB, options, path) {\n  const { enabled, lengthThresholdRelative, lengthThresholdAbsolute } = options.diffMatchPatch, segment = path[path.length - 1];\n  if (!enabled || // Don't use for anything but strings\n  typeof itemA != \"string\" || typeof itemB != \"string\" || // Don't use for `_key`, `_ref` etc\n  typeof segment == \"string\" && segment[0] === \"_\" || // Don't use on short strings\n  itemB.length < lengthThresholdAbsolute)\n    return;\n  let strPatch = \"\";\n  try {\n    const patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makeDiff)(itemA, itemB), diff = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.cleanupEfficiency)(patch);\n    strPatch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.stringifyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makePatches)(diff));\n  } catch {\n    return;\n  }\n  return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : { op: \"diffMatchPatch\", path, value: strPatch };\n}\nfunction diffPrimitive(itemA, itemB, options, path, patches) {\n  const dmp = getDiffMatchPatch(itemA, itemB, options, path);\n  return patches.push(\n    dmp || {\n      op: \"set\",\n      path,\n      value: itemB\n    }\n  ), patches;\n}\nfunction isNotIgnoredKey(key) {\n  return ignoredKeys.indexOf(key) === -1;\n}\nfunction serializePatches(patches, options) {\n  if (patches.length === 0)\n    return [];\n  const { id, ifRevisionID } = options, set = patches.filter((patch) => patch.op === \"set\"), unset = patches.filter((patch) => patch.op === \"unset\"), insert = patches.filter((patch) => patch.op === \"insert\"), dmp = patches.filter((patch) => patch.op === \"diffMatchPatch\"), withSet = set.length > 0 && set.reduce(\n    (patch, item) => {\n      const path = pathToString(item.path);\n      return patch.set[path] = item.value, patch;\n    },\n    { id, set: {} }\n  ), withUnset = unset.length > 0 && unset.reduce(\n    (patch, item) => {\n      const path = pathToString(item.path);\n      return patch.unset.push(path), patch;\n    },\n    { id, unset: [] }\n  ), withInsert = insert.reduce((acc, item) => {\n    const after = pathToString(item.after);\n    return acc.concat({ id, insert: { after, items: item.items } });\n  }, []), withDmp = dmp.length > 0 && dmp.reduce(\n    (patch, item) => {\n      const path = pathToString(item.path);\n      return patch.diffMatchPatch[path] = item.value, patch;\n    },\n    { id, diffMatchPatch: {} }\n  );\n  return [withUnset, withSet, withDmp, ...withInsert].filter(\n    (item) => item !== !1\n  ).map((patch, i) => ({\n    patch: ifRevisionID && i === 0 ? { ...patch, ifRevisionID } : patch\n  }));\n}\nfunction isUniquelyKeyed(arr) {\n  const keys = [];\n  for (let i = 0; i < arr.length; i++) {\n    const key = getKey(arr[i]);\n    if (!key || keys.indexOf(key) !== -1)\n      return !1;\n    keys.push(key);\n  }\n  return !0;\n}\nfunction getKey(obj) {\n  return typeof obj == \"object\" && obj !== null && obj._key;\n}\nfunction indexByKey(arr) {\n  return arr.reduce(\n    (acc, item) => (acc.keys.push(item._key), acc.index[item._key] = item, acc),\n    { keys: [], index: {} }\n  );\n}\nfunction arrayIsEqual(itemA, itemB) {\n  return itemA.length === itemB.length && itemA.every((item, i) => itemB[i] === item);\n}\nfunction nullifyUndefined(item, path, index, options) {\n  if (typeof item < \"u\")\n    return item;\n  if (!options.hideWarnings) {\n    const serializedPath = pathToString(path.concat(index));\n    console.warn(`undefined value in array converted to null (at '${serializedPath}')`);\n  }\n  return null;\n}\nfunction isRevisionLocked(options) {\n  return !!options.ifRevisionID;\n}\nfunction yes(_) {\n  return !0;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sR0FBRyxrQkFBa0I7QUFDNUM7QUFDQSxnQkFBZ0IsT0FBTyxVQUFVLGFBQWE7QUFDOUM7QUFDQSxnQkFBZ0IsT0FBTyxHQUFHLFFBQVE7QUFDbEM7QUFDQSxnQkFBZ0IsT0FBTyxJQUFJLFFBQVE7QUFDbkM7QUFDQSxnQkFBZ0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFFBQVE7QUFDdEQsaURBQWlELFFBQVE7QUFDekQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLE9BQU8sZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWEsS0FBSyxZQUFZO0FBQy9GO0FBQ0Esd0NBQXdDLDBEQUEwRDtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBLDJGQUEyRiwrQkFBK0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLG1DQUFtQyxxQ0FBcUM7QUFDeEU7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLGlDQUFpQyxpQkFBaUIsR0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUE0RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrRUFBUSx1QkFBdUIsMkVBQWlCO0FBQ2xFLGVBQWUsMEVBQWdCLENBQUMscUVBQVc7QUFDM0MsSUFBSTtBQUNKO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYyw0QkFBNEI7QUFDbEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2thdGhvbjItZWNvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL3Nhbml0eS1kaWZmLXBhdGNoL2Rpc3QvaW5kZXguanM/ZDYzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYWtlRGlmZiwgY2xlYW51cEVmZmljaWVuY3ksIHN0cmluZ2lmeVBhdGNoZXMsIG1ha2VQYXRjaGVzIH0gZnJvbSBcIkBzYW5pdHkvZGlmZi1tYXRjaC1wYXRjaFwiO1xuY29uc3QgSVNfRE9UVEFCTEVfUkUgPSAvXltBLVphLXpfXVtBLVphLXowLTlfXSokLztcbmZ1bmN0aW9uIHBhdGhUb1N0cmluZyhwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgodGFyZ2V0LCBzZWdtZW50LCBpKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske3NlZ21lbnQuam9pbihcIjpcIil9XWA7XG4gICAgaWYgKGlzS2V5ZWRPYmplY3Qoc2VnbWVudCkpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVtfa2V5PT1cIiR7c2VnbWVudC5fa2V5fVwiXWA7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske3NlZ21lbnR9XWA7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgJiYgIUlTX0RPVFRBQkxFX1JFLnRlc3Qoc2VnbWVudCkpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVsnJHtzZWdtZW50fSddYDtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9JHtpID09PSAwID8gXCJcIiA6IFwiLlwifSR7c2VnbWVudH1gO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFwiJHtzZWdtZW50fVwiYCk7XG4gIH0sIFwiXCIpO1xufVxuZnVuY3Rpb24gaXNLZXllZE9iamVjdChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLl9rZXkgPT0gXCJzdHJpbmdcIjtcbn1cbmNsYXNzIERpZmZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcGF0aDtcbiAgdmFsdWU7XG4gIHNlcmlhbGl6ZWRQYXRoO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCB2YWx1ZSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXRoID0gcGF0aFRvU3RyaW5nKHBhdGgpO1xuICAgIHN1cGVyKGAke21lc3NhZ2V9IChhdCAnJHtzZXJpYWxpemVkUGF0aH0nKWApLCB0aGlzLnBhdGggPSBwYXRoLCB0aGlzLnNlcmlhbGl6ZWRQYXRoID0gc2VyaWFsaXplZFBhdGgsIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuY29uc3QgaWRQYXR0ZXJuID0gL15bYS16MC05XVthLXowLTlfLi1dKyQvaSwgcHJvcFBhdHRlcm4gPSAvXlthLXpBLVpfXVthLXpBLVowLTlfLV0qJC8sIHByb3BTdGFydFBhdHRlcm4gPSAvXlthLXpfXS9pO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKCFwcm9wU3RhcnRQYXR0ZXJuLnRlc3QocHJvcGVydHkpKVxuICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJLZXlzIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciAoYS16KVwiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgaWYgKCFwcm9wUGF0dGVybi50ZXN0KHByb3BlcnR5KSlcbiAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFxuICAgICAgXCJLZXlzIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycyBhbmQgdW5kZXJzY29yZXNcIixcbiAgICAgIHBhdGguY29uY2F0KHByb3BlcnR5KSxcbiAgICAgIHZhbHVlXG4gICAgKTtcbiAgaWYgKHByb3BlcnR5ID09PSBcIl9rZXlcIiB8fCBwcm9wZXJ0eSA9PT0gXCJfcmVmXCIgfHwgcHJvcGVydHkgPT09IFwiX3R5cGVcIikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJLZXlzIG11c3QgYmUgc3RyaW5nc1wiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgICBpZiAoIWlkUGF0dGVybi50ZXN0KHZhbHVlKSlcbiAgICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJJbnZhbGlkIGtleSAtIHVzZSBsZXNzIGV4b3RpYyBjaGFyYWN0ZXJzXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eTtcbn1cbmNvbnN0IGlnbm9yZWRLZXlzID0gW1wiX2lkXCIsIFwiX3R5cGVcIiwgXCJfY3JlYXRlZEF0XCIsIFwiX3VwZGF0ZWRBdFwiLCBcIl9yZXZcIl0sIGRlZmF1bHRPcHRpb25zID0ge1xuICBoaWRlV2FybmluZ3M6ICExLFxuICBkaWZmTWF0Y2hQYXRjaDoge1xuICAgIGVuYWJsZWQ6ICEwLFxuICAgIC8vIE9ubHkgdXNlIGRpZmYtbWF0Y2gtcGF0Y2ggaWYgdGFyZ2V0IHN0cmluZyBpcyBsb25nZXIgdGhhbiB0aGlzIHRocmVzaG9sZFxuICAgIGxlbmd0aFRocmVzaG9sZEFic29sdXRlOiAzMCxcbiAgICAvLyBPbmx5IHVzZSBnZW5lcmF0ZWQgZGlmZi1tYXRjaC1wYXRjaCBpZiB0aGUgcGF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgIC8vICh0YXJnZXRTdHJpbmcgKiByZWxhdGl2ZSkuIEV4YW1wbGU6IEEgMTAwIGNoYXJhY3RlciB0YXJnZXQgd2l0aCBhIHJlbGF0aXZlIGZhY3RvclxuICAgIC8vIG9mIDEuMiB3aWxsIGFsbG93IGEgMTIwIGNoYXJhY3RlciBkaWZmLW1hdGNoLXBhdGNoLiBJZiBsYXJnZXIgdGhhbiB0aGlzIG51bWJlcixcbiAgICAvLyBpdCB3aWxsIGZhbGwgYmFjayB0byBhIHJlZ3VsYXIgYHNldGAgcGF0Y2guXG4gICAgbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmU6IDEuMlxuICB9XG59O1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zLFxuICAgIGRpZmZNYXRjaFBhdGNoOiB7IC4uLmRlZmF1bHRPcHRpb25zLmRpZmZNYXRjaFBhdGNoLCAuLi5vcHRpb25zLmRpZmZNYXRjaFBhdGNoIHx8IHt9IH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZQYXRjaChpdGVtQSwgaXRlbUIsIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRzIHx8IHt9KSwgaWQgPSBvcHRpb25zLmlkIHx8IGl0ZW1BLl9pZCA9PT0gaXRlbUIuX2lkICYmIGl0ZW1BLl9pZCwgcmV2aXNpb25Mb2NrZWQgPSBvcHRpb25zLmlmUmV2aXNpb25JRCwgaWZSZXZpc2lvbklEID0gdHlwZW9mIHJldmlzaW9uTG9ja2VkID09IFwiYm9vbGVhblwiID8gaXRlbUEuX3JldiA6IHJldmlzaW9uTG9ja2VkLCBiYXNlUGF0aCA9IG9wdGlvbnMuYmFzZVBhdGggfHwgW107XG4gIGlmICghaWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJfaWQgb24gaXRlbUEgYW5kIGl0ZW1CIG5vdCBwcmVzZW50IG9yIGRpZmZlcnMsIHNwZWNpZnkgZG9jdW1lbnQgaWQgdGhlIG11dGF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCB0b1wiXG4gICAgKTtcbiAgaWYgKHJldmlzaW9uTG9ja2VkID09PSAhMCAmJiAhaWZSZXZpc2lvbklEKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGlmUmV2aXNpb25JRGAgaXMgc2V0IHRvIGB0cnVlYCwgYnV0IG5vIGBfcmV2YCB3YXMgcGFzc2VkIGluIGl0ZW0gQS4gRWl0aGVyIGV4cGxpY2l0bHkgc2V0IGBpZlJldmlzaW9uSURgIHRvIGEgcmV2aXNpb24sIG9yIHBhc3MgYF9yZXZgIGFzIHBhcnQgb2YgaXRlbSBBLlwiXG4gICAgKTtcbiAgaWYgKGJhc2VQYXRoLmxlbmd0aCA9PT0gMCAmJiBpdGVtQS5fdHlwZSAhPT0gaXRlbUIuX3R5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBfdHlwZSBpcyBpbW11dGFibGUgYW5kIGNhbm5vdCBiZSBjaGFuZ2VkICgke2l0ZW1BLl90eXBlfSA9PiAke2l0ZW1CLl90eXBlfSlgKTtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IGRpZmZJdGVtKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgYmFzZVBhdGgsIFtdKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZVBhdGNoZXMob3BlcmF0aW9ucywgeyBpZCwgaWZSZXZpc2lvbklEOiByZXZpc2lvbkxvY2tlZCA/IGlmUmV2aXNpb25JRCA6IHZvaWQgMCB9KTtcbn1cbmZ1bmN0aW9uIGRpZmZJdGVtKGl0ZW1BLCBpdGVtQiwgb3B0cyA9IGRlZmF1bHRPcHRpb25zLCBwYXRoID0gW10sIHBhdGNoZXMgPSBbXSkge1xuICBpZiAoaXRlbUEgPT09IGl0ZW1CKVxuICAgIHJldHVybiBwYXRjaGVzO1xuICBjb25zdCBhVHlwZSA9IEFycmF5LmlzQXJyYXkoaXRlbUEpID8gXCJhcnJheVwiIDogdHlwZW9mIGl0ZW1BLCBiVHlwZSA9IEFycmF5LmlzQXJyYXkoaXRlbUIpID8gXCJhcnJheVwiIDogdHlwZW9mIGl0ZW1CLCBhSXNVbmRlZmluZWQgPSBhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIiwgYklzVW5kZWZpbmVkID0gYlR5cGUgPT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChhSXNVbmRlZmluZWQgJiYgIWJJc1VuZGVmaW5lZClcbiAgICByZXR1cm4gcGF0Y2hlcy5wdXNoKHsgb3A6IFwic2V0XCIsIHBhdGgsIHZhbHVlOiBpdGVtQiB9KSwgcGF0Y2hlcztcbiAgaWYgKCFhSXNVbmRlZmluZWQgJiYgYklzVW5kZWZpbmVkKVxuICAgIHJldHVybiBwYXRjaGVzLnB1c2goeyBvcDogXCJ1bnNldFwiLCBwYXRoIH0pLCBwYXRjaGVzO1xuICBjb25zdCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdHMpLCBkYXRhVHlwZSA9IGFJc1VuZGVmaW5lZCA/IGJUeXBlIDogYVR5cGU7XG4gIHJldHVybiBkYXRhVHlwZSA9PT0gXCJvYmplY3RcIiB8fCBkYXRhVHlwZSA9PT0gXCJhcnJheVwiID8gYVR5cGUgIT09IGJUeXBlID8gKHBhdGNoZXMucHVzaCh7IG9wOiBcInNldFwiLCBwYXRoLCB2YWx1ZTogaXRlbUIgfSksIHBhdGNoZXMpIDogZGF0YVR5cGUgPT09IFwiYXJyYXlcIiA/IGRpZmZBcnJheShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIDogZGlmZk9iamVjdChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIDogZGlmZlByaW1pdGl2ZShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xufVxuZnVuY3Rpb24gZGlmZk9iamVjdChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3QgYXRSb290ID0gcGF0aC5sZW5ndGggPT09IDAsIGFLZXlzID0gT2JqZWN0LmtleXMoaXRlbUEpLmZpbHRlcihhdFJvb3QgPyBpc05vdElnbm9yZWRLZXkgOiB5ZXMpLm1hcCgoa2V5KSA9PiB2YWxpZGF0ZVByb3BlcnR5KGtleSwgaXRlbUFba2V5XSwgcGF0aCkpLCBhS2V5c0xlbmd0aCA9IGFLZXlzLmxlbmd0aCwgYktleXMgPSBPYmplY3Qua2V5cyhpdGVtQikuZmlsdGVyKGF0Um9vdCA/IGlzTm90SWdub3JlZEtleSA6IHllcykubWFwKChrZXkpID0+IHZhbGlkYXRlUHJvcGVydHkoa2V5LCBpdGVtQltrZXldLCBwYXRoKSksIGJLZXlzTGVuZ3RoID0gYktleXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBhS2V5c1tpXTtcbiAgICBrZXkgaW4gaXRlbUIgfHwgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidW5zZXRcIiwgcGF0aDogcGF0aC5jb25jYXQoa2V5KSB9KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBiS2V5c1tpXTtcbiAgICBkaWZmSXRlbShpdGVtQVtrZXldLCBpdGVtQltrZXldLCBvcHRpb25zLCBwYXRoLmNvbmNhdChba2V5XSksIHBhdGNoZXMpO1xuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBpZiAoaXRlbUIubGVuZ3RoID4gaXRlbUEubGVuZ3RoICYmIHBhdGNoZXMucHVzaCh7XG4gICAgb3A6IFwiaW5zZXJ0XCIsXG4gICAgYWZ0ZXI6IHBhdGguY29uY2F0KFstMV0pLFxuICAgIGl0ZW1zOiBpdGVtQi5zbGljZShpdGVtQS5sZW5ndGgpLm1hcCgoaXRlbSwgaSkgPT4gbnVsbGlmeVVuZGVmaW5lZChpdGVtLCBwYXRoLCBpLCBvcHRpb25zKSlcbiAgfSksIGl0ZW1CLmxlbmd0aCA8IGl0ZW1BLmxlbmd0aCkge1xuICAgIGNvbnN0IGlzU2luZ2xlID0gaXRlbUEubGVuZ3RoIC0gaXRlbUIubGVuZ3RoID09PSAxLCB1bnNldEl0ZW1zID0gaXRlbUEuc2xpY2UoaXRlbUIubGVuZ3RoKTtcbiAgICBpc1JldmlzaW9uTG9ja2VkKG9wdGlvbnMpIHx8ICFpc1VuaXF1ZWx5S2V5ZWQodW5zZXRJdGVtcykgPyBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgIHBhdGg6IHBhdGguY29uY2F0KFtpc1NpbmdsZSA/IGl0ZW1CLmxlbmd0aCA6IFtpdGVtQi5sZW5ndGgsIFwiXCJdXSlcbiAgICB9KSA6IHBhdGNoZXMucHVzaChcbiAgICAgIC4uLnVuc2V0SXRlbXMubWFwKFxuICAgICAgICAoaXRlbSkgPT4gKHsgb3A6IFwidW5zZXRcIiwgcGF0aDogcGF0aC5jb25jYXQoeyBfa2V5OiBpdGVtLl9rZXkgfSkgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUIubGVuZ3RoOyBpKyspXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbUJbaV0pKVxuICAgICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIk11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIHBhdGguY29uY2F0KGkpLCBpdGVtQltpXSk7XG4gIGNvbnN0IG92ZXJsYXBwaW5nID0gTWF0aC5taW4oaXRlbUEubGVuZ3RoLCBpdGVtQi5sZW5ndGgpLCBzZWdtZW50QSA9IGl0ZW1BLnNsaWNlKDAsIG92ZXJsYXBwaW5nKSwgc2VnbWVudEIgPSBpdGVtQi5zbGljZSgwLCBvdmVybGFwcGluZyk7XG4gIHJldHVybiBpc1VuaXF1ZWx5S2V5ZWQoc2VnbWVudEEpICYmIGlzVW5pcXVlbHlLZXllZChzZWdtZW50QikgPyBkaWZmQXJyYXlCeUtleShzZWdtZW50QSwgc2VnbWVudEIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIDogZGlmZkFycmF5QnlJbmRleChzZWdtZW50QSwgc2VnbWVudEIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5QnlJbmRleChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQS5sZW5ndGg7IGkrKylcbiAgICBkaWZmSXRlbShcbiAgICAgIGl0ZW1BW2ldLFxuICAgICAgbnVsbGlmeVVuZGVmaW5lZChpdGVtQltpXSwgcGF0aCwgaSwgb3B0aW9ucyksXG4gICAgICBvcHRpb25zLFxuICAgICAgcGF0aC5jb25jYXQoaSksXG4gICAgICBwYXRjaGVzXG4gICAgKTtcbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBkaWZmQXJyYXlCeUtleShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3Qga2V5ZWRBID0gaW5kZXhCeUtleShpdGVtQSksIGtleWVkQiA9IGluZGV4QnlLZXkoaXRlbUIpO1xuICBpZiAoIWFycmF5SXNFcXVhbChrZXllZEEua2V5cywga2V5ZWRCLmtleXMpKVxuICAgIHJldHVybiBkaWZmQXJyYXlCeUluZGV4KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZWRCLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXllZEIua2V5c1tpXSwgdmFsdWVBID0ga2V5ZWRBLmluZGV4W2tleV0sIHZhbHVlQiA9IG51bGxpZnlVbmRlZmluZWQoa2V5ZWRCLmluZGV4W2tleV0sIHBhdGgsIGksIG9wdGlvbnMpO1xuICAgIGRpZmZJdGVtKHZhbHVlQSwgdmFsdWVCLCBvcHRpb25zLCBwYXRoLmNvbmNhdCh7IF9rZXk6IGtleSB9KSwgcGF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREaWZmTWF0Y2hQYXRjaChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgpIHtcbiAgY29uc3QgeyBlbmFibGVkLCBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSwgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGUgfSA9IG9wdGlvbnMuZGlmZk1hdGNoUGF0Y2gsIHNlZ21lbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghZW5hYmxlZCB8fCAvLyBEb24ndCB1c2UgZm9yIGFueXRoaW5nIGJ1dCBzdHJpbmdzXG4gIHR5cGVvZiBpdGVtQSAhPSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpdGVtQiAhPSBcInN0cmluZ1wiIHx8IC8vIERvbid0IHVzZSBmb3IgYF9rZXlgLCBgX3JlZmAgZXRjXG4gIHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgJiYgc2VnbWVudFswXSA9PT0gXCJfXCIgfHwgLy8gRG9uJ3QgdXNlIG9uIHNob3J0IHN0cmluZ3NcbiAgaXRlbUIubGVuZ3RoIDwgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGUpXG4gICAgcmV0dXJuO1xuICBsZXQgc3RyUGF0Y2ggPSBcIlwiO1xuICB0cnkge1xuICAgIGNvbnN0IHBhdGNoID0gbWFrZURpZmYoaXRlbUEsIGl0ZW1CKSwgZGlmZiA9IGNsZWFudXBFZmZpY2llbmN5KHBhdGNoKTtcbiAgICBzdHJQYXRjaCA9IHN0cmluZ2lmeVBhdGNoZXMobWFrZVBhdGNoZXMoZGlmZikpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHN0clBhdGNoLmxlbmd0aCA+IGl0ZW1CLmxlbmd0aCAqIGxlbmd0aFRocmVzaG9sZFJlbGF0aXZlID8gdm9pZCAwIDogeyBvcDogXCJkaWZmTWF0Y2hQYXRjaFwiLCBwYXRoLCB2YWx1ZTogc3RyUGF0Y2ggfTtcbn1cbmZ1bmN0aW9uIGRpZmZQcmltaXRpdmUoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGNvbnN0IGRtcCA9IGdldERpZmZNYXRjaFBhdGNoKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCk7XG4gIHJldHVybiBwYXRjaGVzLnB1c2goXG4gICAgZG1wIHx8IHtcbiAgICAgIG9wOiBcInNldFwiLFxuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlOiBpdGVtQlxuICAgIH1cbiAgKSwgcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGlzTm90SWdub3JlZEtleShrZXkpIHtcbiAgcmV0dXJuIGlnbm9yZWRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVQYXRjaGVzKHBhdGNoZXMsIG9wdGlvbnMpIHtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgeyBpZCwgaWZSZXZpc2lvbklEIH0gPSBvcHRpb25zLCBzZXQgPSBwYXRjaGVzLmZpbHRlcigocGF0Y2gpID0+IHBhdGNoLm9wID09PSBcInNldFwiKSwgdW5zZXQgPSBwYXRjaGVzLmZpbHRlcigocGF0Y2gpID0+IHBhdGNoLm9wID09PSBcInVuc2V0XCIpLCBpbnNlcnQgPSBwYXRjaGVzLmZpbHRlcigocGF0Y2gpID0+IHBhdGNoLm9wID09PSBcImluc2VydFwiKSwgZG1wID0gcGF0Y2hlcy5maWx0ZXIoKHBhdGNoKSA9PiBwYXRjaC5vcCA9PT0gXCJkaWZmTWF0Y2hQYXRjaFwiKSwgd2l0aFNldCA9IHNldC5sZW5ndGggPiAwICYmIHNldC5yZWR1Y2UoXG4gICAgKHBhdGNoLCBpdGVtKSA9PiB7XG4gICAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgICByZXR1cm4gcGF0Y2guc2V0W3BhdGhdID0gaXRlbS52YWx1ZSwgcGF0Y2g7XG4gICAgfSxcbiAgICB7IGlkLCBzZXQ6IHt9IH1cbiAgKSwgd2l0aFVuc2V0ID0gdW5zZXQubGVuZ3RoID4gMCAmJiB1bnNldC5yZWR1Y2UoXG4gICAgKHBhdGNoLCBpdGVtKSA9PiB7XG4gICAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgICByZXR1cm4gcGF0Y2gudW5zZXQucHVzaChwYXRoKSwgcGF0Y2g7XG4gICAgfSxcbiAgICB7IGlkLCB1bnNldDogW10gfVxuICApLCB3aXRoSW5zZXJ0ID0gaW5zZXJ0LnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgY29uc3QgYWZ0ZXIgPSBwYXRoVG9TdHJpbmcoaXRlbS5hZnRlcik7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoeyBpZCwgaW5zZXJ0OiB7IGFmdGVyLCBpdGVtczogaXRlbS5pdGVtcyB9IH0pO1xuICB9LCBbXSksIHdpdGhEbXAgPSBkbXAubGVuZ3RoID4gMCAmJiBkbXAucmVkdWNlKFxuICAgIChwYXRjaCwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgcGF0aCA9IHBhdGhUb1N0cmluZyhpdGVtLnBhdGgpO1xuICAgICAgcmV0dXJuIHBhdGNoLmRpZmZNYXRjaFBhdGNoW3BhdGhdID0gaXRlbS52YWx1ZSwgcGF0Y2g7XG4gICAgfSxcbiAgICB7IGlkLCBkaWZmTWF0Y2hQYXRjaDoge30gfVxuICApO1xuICByZXR1cm4gW3dpdGhVbnNldCwgd2l0aFNldCwgd2l0aERtcCwgLi4ud2l0aEluc2VydF0uZmlsdGVyKFxuICAgIChpdGVtKSA9PiBpdGVtICE9PSAhMVxuICApLm1hcCgocGF0Y2gsIGkpID0+ICh7XG4gICAgcGF0Y2g6IGlmUmV2aXNpb25JRCAmJiBpID09PSAwID8geyAuLi5wYXRjaCwgaWZSZXZpc2lvbklEIH0gOiBwYXRjaFxuICB9KSk7XG59XG5mdW5jdGlvbiBpc1VuaXF1ZWx5S2V5ZWQoYXJyKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXJyW2ldKTtcbiAgICBpZiAoIWtleSB8fCBrZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpXG4gICAgICByZXR1cm4gITE7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gZ2V0S2V5KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJiBvYmouX2tleTtcbn1cbmZ1bmN0aW9uIGluZGV4QnlLZXkoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0pID0+IChhY2Mua2V5cy5wdXNoKGl0ZW0uX2tleSksIGFjYy5pbmRleFtpdGVtLl9rZXldID0gaXRlbSwgYWNjKSxcbiAgICB7IGtleXM6IFtdLCBpbmRleDoge30gfVxuICApO1xufVxuZnVuY3Rpb24gYXJyYXlJc0VxdWFsKGl0ZW1BLCBpdGVtQikge1xuICByZXR1cm4gaXRlbUEubGVuZ3RoID09PSBpdGVtQi5sZW5ndGggJiYgaXRlbUEuZXZlcnkoKGl0ZW0sIGkpID0+IGl0ZW1CW2ldID09PSBpdGVtKTtcbn1cbmZ1bmN0aW9uIG51bGxpZnlVbmRlZmluZWQoaXRlbSwgcGF0aCwgaW5kZXgsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBpdGVtIDwgXCJ1XCIpXG4gICAgcmV0dXJuIGl0ZW07XG4gIGlmICghb3B0aW9ucy5oaWRlV2FybmluZ3MpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF0aCA9IHBhdGhUb1N0cmluZyhwYXRoLmNvbmNhdChpbmRleCkpO1xuICAgIGNvbnNvbGUud2FybihgdW5kZWZpbmVkIHZhbHVlIGluIGFycmF5IGNvbnZlcnRlZCB0byBudWxsIChhdCAnJHtzZXJpYWxpemVkUGF0aH0nKWApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNSZXZpc2lvbkxvY2tlZChvcHRpb25zKSB7XG4gIHJldHVybiAhIW9wdGlvbnMuaWZSZXZpc2lvbklEO1xufVxuZnVuY3Rpb24geWVzKF8pIHtcbiAgcmV0dXJuICEwO1xufVxuZXhwb3J0IHtcbiAgRGlmZkVycm9yLFxuICBkaWZmSXRlbSxcbiAgZGlmZlBhdGNoXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanity-diff-patch/dist/index.js\n");

/***/ })

};
;