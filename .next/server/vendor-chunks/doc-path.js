"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/doc-path";
exports.ids = ["vendor-chunks/doc-path"];
exports.modules = {

/***/ "(ssr)/./node_modules/doc-path/lib/path.js":
/*!*******************************************!*\
  !*** ./node_modules/doc-path/lib/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license MIT\n * doc-path <https://github.com/mrodrig/doc-path>\n * Copyright (c) 2015-present, Michael Rodrigues.\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setPath = exports.evaluatePath = void 0;\n/**\n * Main function that evaluates the path in a particular object\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction evaluatePath(obj, kp) {\n    if (!obj) {\n        return null;\n    }\n    const { dotIndex, key, remaining } = state(kp);\n    const kpVal = typeof obj === 'object' && kp in obj ? obj[kp] : undefined;\n    const keyVal = typeof obj === 'object' && key in obj ? obj[key] : undefined;\n    if (dotIndex >= 0 && typeof obj === 'object' && !(kp in obj)) {\n        const { key: nextKey } = state(remaining);\n        const nextKeyAsInt = parseInt(nextKey);\n        // If there's an array at the current key in the object, then iterate over those items evaluating the remaining path\n        if (Array.isArray(keyVal) && isNaN(nextKeyAsInt)) {\n            return keyVal.map((doc) => evaluatePath(doc, remaining));\n        }\n        // Otherwise, we can just recur\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            return keyVal;\n        }\n        // If this object is actually an array, then iterate over those items evaluating the path\n        return obj.map((doc) => evaluatePath(doc, kp));\n    }\n    else if (dotIndex >= 0 && kp !== key && typeof obj === 'object' && key in obj) {\n        // If there's a field with a non-nested dot, then recur into that sub-value\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (dotIndex === -1 && typeof obj === 'object' && key in obj && !(kp in obj)) {\n        // If the field is here, but the key was escaped\n        return keyVal;\n    }\n    // Otherwise, we can just return value directly\n    return kpVal;\n}\nexports.evaluatePath = evaluatePath;\n/**\n * Main function that performs validation before passing off to _sp\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction setPath(obj, kp, v) {\n    if (!obj) {\n        throw new Error('No object was provided.');\n    }\n    else if (!kp) {\n        throw new Error('No keyPath was provided.');\n    }\n    return _sp(obj, kp, v);\n}\nexports.setPath = setPath;\n// Helper function that will set the value in the provided object/array.\nfunction _sp(obj, kp, v) {\n    const { dotIndex, key, remaining } = state(kp);\n    // If this is clearly a prototype pollution attempt, then refuse to modify the path\n    if (kp.startsWith('__proto__') || kp.startsWith('constructor') || kp.startsWith('prototype')) {\n        return obj;\n    }\n    if (dotIndex >= 0) {\n        const keyAsInt = parseInt(key);\n        // If there is a '.' in the key path, recur on the subdoc and ...\n        if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj) && !isNaN(keyAsInt)) {\n            // If there's no value at obj[key] then populate an empty object\n            obj[key] = obj[key] ?? {};\n            // Continue iterating on the rest of the key path to set the appropriate value where intended and then return\n            _sp(obj[key], remaining, v);\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj)) {\n            // If this is an array and there are multiple levels of keys to iterate over, recur.\n            obj.forEach((doc) => _sp(doc, kp, v));\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null && !(key in obj) && !Array.isArray(obj)) {\n            const { key: nextKey } = state(remaining);\n            const nextKeyAsInt = parseInt(nextKey);\n            if (!isNaN(nextKeyAsInt)) {\n                // If the current key doesn't exist yet and the next key is a number (likely array index), populate an empty array\n                obj[key] = [];\n            }\n            else if (remaining === '') {\n                // If the remaining key is empty, then a `.` character appeared right at the end of the path and wasn't actually indicating a separate level\n                obj[kp] = v;\n                return obj;\n            }\n            else {\n                // If the current key doesn't exist yet, populate it\n                obj[key] = {};\n            }\n        }\n        _sp(obj[key], remaining, v);\n    }\n    else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        // If the object is an array and this key is an int (likely array index), then set the value directly and return\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            obj[key] = v;\n            return obj;\n        }\n        // If this \"obj\" is actually an array, then we can loop over each of the values and set the path\n        obj.forEach((doc) => _sp(doc, remaining, v));\n        return obj;\n    }\n    else {\n        // Otherwise, we can set the path directly\n        obj[key] = v;\n    }\n    return obj;\n}\n// Helper function that returns some information necessary to evaluate or set a path  based on the provided keyPath value\nfunction state(kp) {\n    const dotIndex = findFirstNonEscapedDotIndex(kp);\n    return {\n        dotIndex,\n        key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\\\./g, '.'),\n        remaining: kp.slice(dotIndex + 1)\n    };\n}\nfunction findFirstNonEscapedDotIndex(kp) {\n    for (let i = 0; i < kp.length; i++) {\n        const previousChar = i > 0 ? kp[i - 1] : '', currentChar = kp[i];\n        if (currentChar === '.' && previousChar !== '\\\\')\n            return i;\n    }\n    return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jLXBhdGgvbGliL3BhdGguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxvQkFBb0I7QUFDdEM7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2F0aG9uMi1lY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvZG9jLXBhdGgvbGliL3BhdGguanM/Y2Y4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIE1JVFxuICogZG9jLXBhdGggPGh0dHBzOi8vZ2l0aHViLmNvbS9tcm9kcmlnL2RvYy1wYXRoPlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIE1pY2hhZWwgUm9kcmlndWVzLlxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldFBhdGggPSBleHBvcnRzLmV2YWx1YXRlUGF0aCA9IHZvaWQgMDtcbi8qKlxuICogTWFpbiBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0aGUgcGF0aCBpbiBhIHBhcnRpY3VsYXIgb2JqZWN0XG4gKiBAdGhyb3dzIHtFcnJvcn0gcG9zc2libGUgZXJyb3IgaWYgY2FsbCBzdGFjayBzaXplIGlzIGV4Y2VlZGVkXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlUGF0aChvYmosIGtwKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgZG90SW5kZXgsIGtleSwgcmVtYWluaW5nIH0gPSBzdGF0ZShrcCk7XG4gICAgY29uc3Qga3BWYWwgPSB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBrcCBpbiBvYmogPyBvYmpba3BdIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGtleVZhbCA9IHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmogPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZG90SW5kZXggPj0gMCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhKGtwIGluIG9iaikpIHtcbiAgICAgICAgY29uc3QgeyBrZXk6IG5leHRLZXkgfSA9IHN0YXRlKHJlbWFpbmluZyk7XG4gICAgICAgIGNvbnN0IG5leHRLZXlBc0ludCA9IHBhcnNlSW50KG5leHRLZXkpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGFycmF5IGF0IHRoZSBjdXJyZW50IGtleSBpbiB0aGUgb2JqZWN0LCB0aGVuIGl0ZXJhdGUgb3ZlciB0aG9zZSBpdGVtcyBldmFsdWF0aW5nIHRoZSByZW1haW5pbmcgcGF0aFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlWYWwpICYmIGlzTmFOKG5leHRLZXlBc0ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlWYWwubWFwKChkb2MpID0+IGV2YWx1YXRlUGF0aChkb2MsIHJlbWFpbmluZykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIGp1c3QgcmVjdXJcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlUGF0aChrZXlWYWwsIHJlbWFpbmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCBrZXlBc0ludCA9IHBhcnNlSW50KGtleSk7XG4gICAgICAgIGlmIChrcCA9PT0ga2V5ICYmIGRvdEluZGV4ID09PSAtMSAmJiAhaXNOYU4oa2V5QXNJbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5VmFsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGFjdHVhbGx5IGFuIGFycmF5LCB0aGVuIGl0ZXJhdGUgb3ZlciB0aG9zZSBpdGVtcyBldmFsdWF0aW5nIHRoZSBwYXRoXG4gICAgICAgIHJldHVybiBvYmoubWFwKChkb2MpID0+IGV2YWx1YXRlUGF0aChkb2MsIGtwKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvdEluZGV4ID49IDAgJiYga3AgIT09IGtleSAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBrZXkgaW4gb2JqKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBmaWVsZCB3aXRoIGEgbm9uLW5lc3RlZCBkb3QsIHRoZW4gcmVjdXIgaW50byB0aGF0IHN1Yi12YWx1ZVxuICAgICAgICByZXR1cm4gZXZhbHVhdGVQYXRoKGtleVZhbCwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG90SW5kZXggPT09IC0xICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmogJiYgIShrcCBpbiBvYmopKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBpcyBoZXJlLCBidXQgdGhlIGtleSB3YXMgZXNjYXBlZFxuICAgICAgICByZXR1cm4ga2V5VmFsO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHdlIGNhbiBqdXN0IHJldHVybiB2YWx1ZSBkaXJlY3RseVxuICAgIHJldHVybiBrcFZhbDtcbn1cbmV4cG9ydHMuZXZhbHVhdGVQYXRoID0gZXZhbHVhdGVQYXRoO1xuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdmFsaWRhdGlvbiBiZWZvcmUgcGFzc2luZyBvZmYgdG8gX3NwXG4gKiBAdGhyb3dzIHtFcnJvcn0gcG9zc2libGUgZXJyb3IgaWYgY2FsbCBzdGFjayBzaXplIGlzIGV4Y2VlZGVkXG4gKi9cbmZ1bmN0aW9uIHNldFBhdGgob2JqLCBrcCwgdikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gb2JqZWN0IHdhcyBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWtwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8ga2V5UGF0aCB3YXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBfc3Aob2JqLCBrcCwgdik7XG59XG5leHBvcnRzLnNldFBhdGggPSBzZXRQYXRoO1xuLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBzZXQgdGhlIHZhbHVlIGluIHRoZSBwcm92aWRlZCBvYmplY3QvYXJyYXkuXG5mdW5jdGlvbiBfc3Aob2JqLCBrcCwgdikge1xuICAgIGNvbnN0IHsgZG90SW5kZXgsIGtleSwgcmVtYWluaW5nIH0gPSBzdGF0ZShrcCk7XG4gICAgLy8gSWYgdGhpcyBpcyBjbGVhcmx5IGEgcHJvdG90eXBlIHBvbGx1dGlvbiBhdHRlbXB0LCB0aGVuIHJlZnVzZSB0byBtb2RpZnkgdGhlIHBhdGhcbiAgICBpZiAoa3Auc3RhcnRzV2l0aCgnX19wcm90b19fJykgfHwga3Auc3RhcnRzV2l0aCgnY29uc3RydWN0b3InKSB8fCBrcC5zdGFydHNXaXRoKCdwcm90b3R5cGUnKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoZG90SW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBrZXlBc0ludCA9IHBhcnNlSW50KGtleSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgJy4nIGluIHRoZSBrZXkgcGF0aCwgcmVjdXIgb24gdGhlIHN1YmRvYyBhbmQgLi4uXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgIShrZXkgaW4gb2JqKSAmJiBBcnJheS5pc0FycmF5KG9iaikgJiYgIWlzTmFOKGtleUFzSW50KSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyB2YWx1ZSBhdCBvYmpba2V5XSB0aGVuIHBvcHVsYXRlIGFuIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgb2JqW2tleV0gPSBvYmpba2V5XSA/PyB7fTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGl0ZXJhdGluZyBvbiB0aGUgcmVzdCBvZiB0aGUga2V5IHBhdGggdG8gc2V0IHRoZSBhcHByb3ByaWF0ZSB2YWx1ZSB3aGVyZSBpbnRlbmRlZCBhbmQgdGhlbiByZXR1cm5cbiAgICAgICAgICAgIF9zcChvYmpba2V5XSwgcmVtYWluaW5nLCB2KTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmICEoa2V5IGluIG9iaikgJiYgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGFycmF5IGFuZCB0aGVyZSBhcmUgbXVsdGlwbGUgbGV2ZWxzIG9mIGtleXMgdG8gaXRlcmF0ZSBvdmVyLCByZWN1ci5cbiAgICAgICAgICAgIG9iai5mb3JFYWNoKChkb2MpID0+IF9zcChkb2MsIGtwLCB2KSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiAhKGtleSBpbiBvYmopICYmICFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5OiBuZXh0S2V5IH0gPSBzdGF0ZShyZW1haW5pbmcpO1xuICAgICAgICAgICAgY29uc3QgbmV4dEtleUFzSW50ID0gcGFyc2VJbnQobmV4dEtleSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKG5leHRLZXlBc0ludCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBrZXkgZG9lc24ndCBleGlzdCB5ZXQgYW5kIHRoZSBuZXh0IGtleSBpcyBhIG51bWJlciAobGlrZWx5IGFycmF5IGluZGV4KSwgcG9wdWxhdGUgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVtYWluaW5nID09PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZW1haW5pbmcga2V5IGlzIGVtcHR5LCB0aGVuIGEgYC5gIGNoYXJhY3RlciBhcHBlYXJlZCByaWdodCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3YXNuJ3QgYWN0dWFsbHkgaW5kaWNhdGluZyBhIHNlcGFyYXRlIGxldmVsXG4gICAgICAgICAgICAgICAgb2JqW2twXSA9IHY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGtleSBkb2Vzbid0IGV4aXN0IHlldCwgcG9wdWxhdGUgaXRcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zcChvYmpba2V5XSwgcmVtYWluaW5nLCB2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGtleUFzSW50ID0gcGFyc2VJbnQoa2V5KTtcbiAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbiBhcnJheSBhbmQgdGhpcyBrZXkgaXMgYW4gaW50IChsaWtlbHkgYXJyYXkgaW5kZXgpLCB0aGVuIHNldCB0aGUgdmFsdWUgZGlyZWN0bHkgYW5kIHJldHVyblxuICAgICAgICBpZiAoa3AgPT09IGtleSAmJiBkb3RJbmRleCA9PT0gLTEgJiYgIWlzTmFOKGtleUFzSW50KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIFwib2JqXCIgaXMgYWN0dWFsbHkgYW4gYXJyYXksIHRoZW4gd2UgY2FuIGxvb3Agb3ZlciBlYWNoIG9mIHRoZSB2YWx1ZXMgYW5kIHNldCB0aGUgcGF0aFxuICAgICAgICBvYmouZm9yRWFjaCgoZG9jKSA9PiBfc3AoZG9jLCByZW1haW5pbmcsIHYpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIHNldCB0aGUgcGF0aCBkaXJlY3RseVxuICAgICAgICBvYmpba2V5XSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG4vLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHNvbWUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGV2YWx1YXRlIG9yIHNldCBhIHBhdGggIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBrZXlQYXRoIHZhbHVlXG5mdW5jdGlvbiBzdGF0ZShrcCkge1xuICAgIGNvbnN0IGRvdEluZGV4ID0gZmluZEZpcnN0Tm9uRXNjYXBlZERvdEluZGV4KGtwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb3RJbmRleCxcbiAgICAgICAga2V5OiBrcC5zbGljZSgwLCBkb3RJbmRleCA+PSAwID8gZG90SW5kZXggOiB1bmRlZmluZWQpLnJlcGxhY2UoL1xcXFwuL2csICcuJyksXG4gICAgICAgIHJlbWFpbmluZzoga3Auc2xpY2UoZG90SW5kZXggKyAxKVxuICAgIH07XG59XG5mdW5jdGlvbiBmaW5kRmlyc3ROb25Fc2NhcGVkRG90SW5kZXgoa3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ2hhciA9IGkgPiAwID8ga3BbaSAtIDFdIDogJycsIGN1cnJlbnRDaGFyID0ga3BbaV07XG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy4nICYmIHByZXZpb3VzQ2hhciAhPT0gJ1xcXFwnKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/doc-path/lib/path.js\n");

/***/ })

};
;